// April 19, 2014
// http://www.spaceinvaders.de/
// sounds at http://www.classicgaming.cc/classics/spaceinvaders/sounds.php
// http://www.classicgaming.cc/classics/spaceinvaders/playguide.php
/* This example accompanies the books
   "Embedded Systems: Real Time Interfacing to Arm Cortex M Microcontrollers",
   ISBN: 978-1463590154, Jonathan Valvano, copyright (c) 2013

   "Embedded Systems: Introduction to Arm Cortex M Microcontrollers",
   ISBN: 978-1469998749, Jonathan Valvano, copyright (c) 2013

 Copyright 2014 by Jonathan W. Valvano, valvano@mail.utexas.edu
    You may use, edit, run or distribute this file
    as long as the above copyright notice remains
 THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
 OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
 VALVANO SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL,
 OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 For more information about my classes, my research, and my books, see
 http://users.ece.utexas.edu/~valvano/
 */
// ******* Required Hardware I/O connections*******************
// PA1, PA0 UART0 connected to PC through USB cable
// Slide pot pin 1 connected to ground
// Slide pot pin 2 connected to PE2/AIN1
// Slide pot pin 3 connected to +3.3V 
// fire button connected to PE0
// special weapon fire button connected to PE1
// 8*R resistor DAC bit 0 on PB0 (least significant bit)
// 4*R resistor DAC bit 1 on PB1
// 2*R resistor DAC bit 2 on PB2
// 1*R resistor DAC bit 3 on PB3 (most significant bit)
// LED on PB4
// LED on PB5


//written by Daniel Truong

#include "..//tm4c123gh6pm.h"
#include "Nokia5110.h"
#include "Random.h"
#include "TExaS.h"
#include "Controls.h"
#include "Sound.h"
#include "math.h"

//max width = 84, max height = 48

// *************************** Images ***************************
// enemy ship that starts at the top of the screen (arms/mouth closed)
// width=16 x height=10
const unsigned char SmallEnemy30PointA[] = {
 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x0F, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
 0xFF, 0x0F, 0xF0, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// enemy ship that starts at the top of the screen (arms/mouth open)
// width=16 x height=10
const unsigned char SmallEnemy30PointB[] = {
 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F,
 0x0F, 0x00, 0x00, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
 0xFF, 0x0F, 0xF0, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// enemy ship that starts in the middle of the screen (arms together)
// width=16 x height=10
const unsigned char SmallEnemy20PointA[] = {
 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x0F, 0xF0, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0xFF, 0xF0, 0x0F, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
 0xF0, 0x0F, 0xF0, 0x0F, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// enemy ship that starts in the middle of the screen (arms apart)
// width=16 x height=10
const unsigned char SmallEnemy20PointB[] = {
 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0,
 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x0F, 0xF0, 0x0F, 0xF0, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0xFF, 0xF0, 0x0F, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
 0xF0, 0x0F, 0xF0, 0x0F, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// enemy ship that starts at the bottom of the screen (arms down)
// width=16 x height=10
const unsigned char SmallEnemy10PointA[] = {
 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x0F, 0xF0, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0F,
 0xF0, 0xFF, 0xFF, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// enemy ship that starts at the bottom of the screen (arms up)
// width=16 x height=10
const unsigned char SmallEnemy10PointB[] = {
 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F,
 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
 0xF0, 0xFF, 0xFF, 0x0F, 0xFF, 0x00, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0xF0, 0x0F, 0x00, 0x00, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// image of the player's ship
// includes two blacked out columns on the left and right sides of the image to prevent smearing when moved 2 pixels to the left or right
// width=18 x height=8
const unsigned char PlayerShip0[] = {
 0x42, 0x4D, 0xD6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00,
 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0xAA, 0xAA, 0xAA,
 0xAA, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// small, fast bonus enemy that occasionally speeds across the top of the screen after enough enemies have been killed to make room for it
// includes two blacked out columns on the left and right sides of the image to prevent smearing when moved 2 pixels to the left or right
// width=20 x height=7
const unsigned char SmallEnemyBonus0[] = {
 0x42, 0x4D, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0xFF, 0xF0, 0x0F, 0xF0, 0x0F, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0xFF, 0x0F, 0xF0,
 0xFF, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x0F, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// small shield floating in space to cover the player's ship from enemy fire (undamaged)
// width=18 x height=5
const unsigned char Bunker0[] = {
 0x42, 0x4D, 0xB2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0x00,
 0x00, 0x00, 0xAA, 0xAA, 0xA0, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
 0xAA, 0xAA, 0xA0, 0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x00, 0xFF};

// small shield floating in space to cover the player's ship from enemy fire (moderate generic damage)
// width=18 x height=5
const unsigned char Bunker1[] = {
 0x42, 0x4D, 0xB2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0x00,
 0x00, 0x00, 0xAA, 0xAA, 0xA0, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x0A, 0xAA, 0xAA, 0xAA, 0xAA, 0xA0, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0x0A, 0xA0, 0xA0, 0xAA,
 0xAA, 0xA0, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xA0, 0x00, 0x0A, 0x0A, 0x0A, 0x00, 0x00, 0x00, 0x00, 0xFF};

// small shield floating in space to cover the player's ship from enemy fire (heavy generic damage)
// width=18 x height=5
const unsigned char Bunker2[] = {
 0x42, 0x4D, 0xB2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x0A, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xAA, 0x00,
 0x00, 0x00, 0xAA, 0x0A, 0xA0, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x0A, 0x0A, 0xA0, 0xAA, 0xA0, 0xA0, 0xA0, 0xA0, 0x00, 0x00, 0x00, 0x00, 0xAA, 0x0A, 0x00, 0xA0, 0xA0,
 0xA0, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// blank space used to cover a bunker that is destroyed
// width=18 x height=5
/*const unsigned char Bunker3[] = {
 0x42, 0x4D, 0xB2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};
*/
 
// large explosion that can be used upon the demise of the player's ship (first frame)
// width=18 x height=8
const unsigned char BigExplosion0[] = {
 0x42, 0x4D, 0xD6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x0A, 0x00, 0x09, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x90, 0x00, 0x90, 0xB0, 0x0A, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0xA0, 0x00, 0xE0, 0x00, 0x00,
 0x90, 0x90, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0xA0, 0x00, 0x00, 0xAE, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00,
 0x00, 0xE0, 0x0A, 0x0A, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x09, 0x00, 0x00, 0x00, 0x90, 0x00, 0x0A, 0x00, 0x00, 0x00, 0xFF};

// large explosion that can be used upon the demise of the player's ship (second frame)
// width=18 x height=8
const unsigned char BigExplosion1[] = {
 0x42, 0x4D, 0xD6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x0E, 0x00, 0x09, 0x00, 0x09, 0x00, 0xB0, 0x00, 0xA0, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA9, 0x00, 0x00, 0x00, 0x00, 0x90,
 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x0A, 0x00, 0x90, 0x00, 0xB0, 0x00, 0x09, 0x00, 0x00, 0x00, 0xFF};

// small explosion best used for the demise of an enemy
// width=16 x height=10
const unsigned char SmallExplosion0[] = {
 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0,
 0x0F, 0x00, 0x0F, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0xF0, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
 0xF0, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x00, 0xF0, 0xF0, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// blank space following the small explosion for the demise of an enemy
// width=16 x height=10
/*const unsigned char SmallExplosion1[] = {
 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};
*/
 
// a missile in flight
// includes one blacked out row on the top, bottom, and right of the image to prevent smearing when moved 1 pixel down, up, or left
// width=4 x height=9
const unsigned char Laser0[] = {
 0x42, 0x4D, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x00,
 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// a missile in flight
// includes one blacked out row on the top, bottom, and left of the image to prevent smearing when moved 1 pixel down, up, or right
// width=4 x height=9
const unsigned char Laser1[] = {
 0x42, 0x4D, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x0F,
 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// blank space to cover a missile after it hits something
// width=4 x height=9
/*const unsigned char Laser2[] = {
 0x42, 0x4D, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};
*/
	
// a laser burst in flight
// includes one blacked out row on the top and bottom of the image to prevent smearing when moved 1 pixel up or down
// width=2 x height=9
const unsigned char Missile0[] = {
 0x42, 0x4D, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0xBB, 0x00,
 0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// blank space to cover a laser after it hits something
// width=2 x height=9
/*const unsigned char Missile1[] = {
 0x42, 0x4D, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};
*/


// *************************** Capture image dimensions out of BMP**********
#define NULL 0	
	
#define BUNKERW     ((unsigned char)Bunker0[18])
#define BUNKERH     ((unsigned char)Bunker0[22])
#define ENEMY30W    ((unsigned char)SmallEnemy30PointA[18])
#define ENEMY30H    ((unsigned char)SmallEnemy30PointA[22])
#define ENEMY20W    ((unsigned char)SmallEnemy20PointA[18])
#define ENEMY20H    ((unsigned char)SmallEnemy20PointA[22])
#define ENEMY10W    ((unsigned char)SmallEnemy10PointA[18])
#define ENEMY10H    ((unsigned char)SmallEnemy10PointA[22])
#define ENEMYBONUSW ((unsigned char)SmallEnemyBonus0[18])
#define ENEMYBONUSH ((unsigned char)SmallEnemyBonus0[22])
#define MISSILEW      ((unsigned char)Missile0[18])
#define MISSILEH      ((unsigned char)Missile0[22])
#define LASERW    ((unsigned char)Laser0[18])
#define LASERH    ((unsigned char)Laser0[22])
#define PLAYERW     ((unsigned char)PlayerShip0[18])
#define PLAYERH     ((unsigned char)PlayerShip0[22])
#define PLAYERHALF (PLAYERW / 2)
#define ENEMYHALF (ENEMY30W / 2)


#define SCALE (4095/(MAX_X - PLAYERW - 1))

#define BASE_CLOCK 80000000

#define MAX_ENEMIES 10
#define MAX_BUNKERS 2
#define MAX_STAGES 3
#define MAX_LASERS 3
#define MAX_PER_ROW 4
#define STARTING_SPEED 1


static unsigned long Semaphore; //triggered when sprites have moved and needs to rendered outs
static unsigned short ADCdata; //current ADCdata value returned by the ADC0 (connected to potentiometer)
static unsigned short prev_ADCdata; //keeps track of the previous ADCdata value

extern unsigned long flag; //flag is set if sound is over

typedef struct Weapon {
	const unsigned char *image[2]; // two pointers to images
	unsigned long life;            // 0=dead, 1=alive
	unsigned long x;      // x coordinate
  unsigned long y;      // y coordinate
	unsigned long w; //width
	unsigned long h; //height
	signed long direction; //positive means down, negative means down
} Wpn;


typedef struct Entity {
	const unsigned char *image[3]; // two pointers to imagesc:
	unsigned long life;            // 0=dead, 1=alive
	unsigned long x;      // x coordinate
  unsigned long y;      // y coordinate
	unsigned long w; //width
	unsigned long h; //height
	unsigned long score; //holds the score pertaining to each enemy and the score collected by the player
	unsigned long death; //frame to play when the entity dies
} Ent;        

typedef struct Enemy {
	Wpn Laser;
	const unsigned char *image[3]; // two pointers to imagesc:
	unsigned long id; //unique id for enemy
	unsigned long life;            // 0=dead, 1=alive
	unsigned long x;      // x coordinate
  unsigned long y;      // y coordinate
	unsigned long w; //width
	unsigned long h; //height
	unsigned long can_shoot; //boolean that determines whether enemy can shoot or not
	unsigned long score; //holds the score pertaining to each enemy and the score collected by the player
	unsigned long death; //frame to play when the entity dies
	struct Enemy* next; //points to the next enemy in list
	struct Enemy* prev; //points to the prev enemy in list
} Enmy;

struct{
	unsigned long num_enemies[MAX_STAGES]; //array to hold the number of enemies for each stage
	unsigned long num_bunkers[MAX_STAGES]; //array to hold the number of bunkers for each stage
	unsigned long level; //current stage level
} Stage;


struct {
	Ent Ship; //struct that contains all the ship info
	Wpn Missile; //struct that contains all the missile info
	unsigned long lives; //number of lives the player has
} Player;

struct {
	Ent Bunker[MAX_BUNKERS]; //array to hold all the bunkers
	unsigned long num_bunkers; //number of bunkers
}B;

struct {
	Enmy Enemy[MAX_ENEMIES]; //array to hold all the enemies
	Enmy BonusEnemy; // Bonus Enemy
	Enmy* Shot[MAX_LASERS]; //array that keeps track of which enemies shot their laser
	unsigned long speed; //speed of the enemy
	unsigned long num_enemies; //number of enemies alive
	unsigned long num_lasers; //number of lasers alive
	unsigned long enemy_frame; //frame to play when the enemy or laser is alive
	unsigned long laser_frame; //frame to play for the laser
	signed long direction; //positive means move right, negative means move left
	Enmy* head; //points to the first enemy in the list
	Enmy* tail; //points to the last enemy in the list
	Enmy* right; //keeps track of the rightmost enemy
	Enmy* left; //keeps track of the leftmost enemy
} E;

typedef struct Point{
	unsigned long x;
	unsigned long y;
}Pnt;

typedef struct Rectangle{
	Pnt L;
	Pnt R;
} Rect;


/*
input: unsigned long lower, unsigned long upper
output: randomly generated unsigned integer 
desc: this function produces a random number ranging from [lower, upper]
*/
unsigned long Generate_Random(unsigned long lower, unsigned long upper);

/*
input: unsigned long count
output: none
desc: this function delays the program by (100ms * count)
*/
void Delay100ms(unsigned long count);

/*
input: unsigned long num_enemies
output: none 
desc: this function initializes the number of enemies specified by num_enemies
*/
void Init_Enemy(unsigned long num_enemies);

/*
input: unsigned long num_bunkers
output: none 
desc: this function initializes the number of bunkers specified by num_bunkers
*/
void Init_Bunker(unsigned long num_bunkers);

/*
input: none
output: none 
desc: this function initializes the player
*/
void Init_Player(void);

/*
input: none
output: none 
desc: this function initializes the players missile
*/
void Init_Missile(void);

/*
input: none
output: none 
desc: this function initializes the bonus enemy
*/
void Init_BonusEnemy(void);

/*
input: a pointer to Enmy type "enemy"
output: none 
desc: this function initializes the enemy laser
*/
void Init_Laser(Enmy* enemy);

/*
input: none
output: none 
desc: this function initializes the stage's number of enemies and bunkers for each level
*/
void Init_Stage(void);

/*
input: none
output: none 
desc: this function changes the next level of the stage
*/
void Change_Stage(void);

/*
input: none
output: none 
desc: this function finds the rightmost and leftmost enemy
*/
void Find_RightLeft(void);

/*
input: a pointer to Enmy type "enemy"
output: none
desc: this function removes "enemy" from the enemy linked list
*/
void Remove_Enemy(Enmy* enemy);

/*
input: unsigned long j
output: none
desc: this function removes an enemy from the shooter's list (array)
*/
void Remove_Shooter(unsigned long j);

/*
input: a pointer to Rect R1 , a pointer to Rect R2 
output: 1 if rectangles overlap, else 0 
desc: this function checks to see whether the two rectangles R1 and R2 overlap
*/
unsigned long Is_Overlapping(Rect* R1, Rect* R2);

/*
input: a pointer to a Wpn called Projectile
output: none 
desc: this function checks whether the weapon pointed by Projectile collides with any other object
*/
void Check_Collision(Wpn* Projectile);

/*
input: unsigned long ADCinput
output: none 
desc: this function moves the player based on the value of ADCinput
*/
void Move_Player(unsigned long ADCinput);


/*
input: none
output: none 
desc: this function moves the Bonus Enemy
*/
void Move_BonusEnemy(void);

/*
input: a pointer to a Wpn called Projectile
output: none 
desc: this function moves the weapon pointed by Projectile
*/
void Move_Projectile(Wpn* Projectile);

/*
input: signed long x_operand
output: none 
desc: this function moves all living enemies horizontally by x_operand
*/
void Move_X_Enemy(signed long x_operand);

/*
input: signd long y_operand
output: none 
desc: this function moves all living enemies vertically by y_operand
*/
void Move_Y_Enemy(signed long y_operand);

/*
input: none
output: none 
desc: this function updates the enemies locations, spawns in a bonus enemy, and randomly chooses which enemy shoots
*/
void Update_Enemy(void);

/*
input: none
output: none 
desc: this function draws the player and missile sprite into Nokia display
*/
void Draw_Player(void);

/*
input: none
output: none 
desc: this function draws the enemies and laser sprite into Nokia display
*/
void Draw_Enemy(void);

/*
input: none
output: none 
desc: this function draws the bunkers sprite into Nokia display
*/
void Draw_Bunker(void);

/*
input: none
output: none 
desc: this function draws all the sprites into Nokia display
*/
void Draw(void);

/*
input: none
output: none 
desc: this function prints the congrats screen into the Nokia display
*/
void Print_Congrats(void);

/*
input: none
output: none 
desc: this function prints the game over screen into the Nokia display
*/
void Print_GameOver(void);

/*
input: none
output: none 
desc: this function prints the start screen into the Nokia display
*/
void Print_Start(void);

/*
input: none
output: none 
desc: this function disables any sprite updates from rendering
*/
void Disable_Update(void);

/*
input: none
output: none 
desc: this function enables any sprite updates to render
*/
void Enable_Update(void);

/*
input: none
output: none 
desc: this function disables all maskable interrupts 
*/
void DisableInterrupts(void);

/*
input: none
output: none 
desc: this function enables all maskable interrupts
*/
void EnableInterrupts(void);

/*
input: none
output: none 
desc: this function initializes all timer and edge triggered interrupts
*/
void Init_Interrupts(void);

/*
input: none
output: none 
desc: this function initializes the players missile when PE0 is pressed
*/
void GPIOPortE_Handler(void);

/*
input: none
output: none 
desc: this function outputs non-atomic sound to the audio jack for every tick
*/
void Timer0A_Handler(void);

/*
input: none
output: none 
desc: this function outputs atomic sound to the audio jack for every tick
*/
void Timer2A_Handler(void);

/*
input: none
output: none 
desc: this function handles moving the laser, missile, bonus enemy, and players sprite for every tick
*/
void Timer3A_Handler(void);

/*
input: none
output: none 
desc: this function handles moving the enemy sprites for every tick
*/
void Timer1A_Handler(void);

/*
input: unsigned long period
output: none 
desc: this function updates the timer's countdown time to the value specified by period
*/
void Timer1_Update(unsigned long period);

/*
input: none
output: none 
desc: this function initializes Timer1's configuration and sets the timer's countdown time to the value specified by period
*/
void Timer1_Init(unsigned long period);

/*
input: none
output: none 
desc: this function disables the Systick timer
*/
void Systick_Disable(void);

/*
input: none
output: none 
desc: this function initalizes the Systick timer configuration 
*/
void Systick_Init(void);


/*
input: unsigned long lower, unsigned long upper
output: randomly generated unsigned integer 
desc: this function produces a random number ranging from [lower, upper]
*/
unsigned long Generate_Random(unsigned long lower, unsigned long upper){
	return ((Random()>>24) % (upper - lower + 1)) + lower;
}

/*
input: unsigned long count
output: none
desc: this function delays the program by (100ms * count)
*/
void Delay100ms(unsigned long count){unsigned long volatile time;
  while(count>0){
    time = 727240;  // 0.1sec at 80 MHz
    while(time){
	  	time--;
    }
    count--;
  }
}

/*
input: none
output: none 
desc: this function initializes the player
*/
void Init_Player(void){
	ADCdata = ADC_In(); //get potentiometer reading
	
	Move_Player(ADCdata); //set x player position
	
	Player.Ship.y = MAX_Y - 1; //set y player position
	Player.Ship.w = PLAYERW;
	Player.Ship.h = PLAYERH;
	Player.Ship.image[0] = PlayerShip0; 
	Player.Ship.image[1] = BigExplosion0;
	Player.Ship.image[2] = BigExplosion1;
	Player.Ship.score = 0;
	Player.Ship.life = 1; //set the player alive
	Player.Ship.death = 0;
	
	
	Player.Missile.w = MISSILEW;
	Player.Missile.h = MISSILEH;
	Player.Missile.direction = -1; //traveling up
	Player.Missile.image[0] = Missile0;
	Player.Missile.life = 0;
	
	Player.lives = 3;
	
	prev_ADCdata = ADCdata; 
}

/*
input: none
output: none 
desc: this function initializes the bonus enemy
*/
void Init_BonusEnemy(){
	E.BonusEnemy.life = 1;
	E.BonusEnemy.x = 0;
	E.BonusEnemy.y = ENEMY30H;
	E.BonusEnemy.w = ENEMYBONUSW;
	E.BonusEnemy.h = ENEMYBONUSH;
	E.BonusEnemy.can_shoot = 0;
	E.BonusEnemy.score = 100;
	E.BonusEnemy.image[0] = SmallEnemyBonus0;
	E.BonusEnemy.death = 0;
	
	//start bonus enemy sound
	Sound_Highpitch();
}

/*
input: a pointer to Enmy type Enemy
output: none 
desc: this function initializes the enemy laser
*/
void Init_Laser(Enmy* enemy){
	enemy->Laser.x = enemy->x + ENEMYHALF - 1;
	enemy->Laser.y = enemy->y + 2;
	enemy->Laser.life = 1;
	
	E.Shot[E.num_lasers] = enemy;
	E.num_lasers++;
}

/*
input: none
output: none 
desc: this function initializes the players missile
*/
void Init_Missile(void){
	Player.Missile.x = Player.Ship.x + PLAYERHALF - 1;
	Player.Missile.y = Player.Ship.y - PLAYERH;
	Player.Missile.life = 1;
	
	//start the missile sound
	Sound_Shoot();
}

/*
input: unsigned long num_bunkers
output: none 
desc: this function initializes the number of bunkers specified by num_bunkers
*/
void Init_Bunker(unsigned long num_bunkers){
	unsigned long i;
	unsigned long x_spacing = (MAX_X - BUNKERW) / num_bunkers;
	unsigned long x_offset = x_spacing>>1;
	unsigned long y_offset = MAX_Y - PLAYERH - 2;
	
	B.num_bunkers = num_bunkers;
		
	//initialize the bunkers
	for(i=0;i<num_bunkers;i++){
		B.Bunker[i].x = x_offset + x_spacing * i;
		B.Bunker[i].y = y_offset;
		B.Bunker[i].w = BUNKERW;
		B.Bunker[i].h = BUNKERH;
		B.Bunker[i].image[0] = Bunker0;
		B.Bunker[i].image[1] = Bunker1;
		B.Bunker[i].image[2] = Bunker2;
		B.Bunker[i].life = 3;
	}
}

/*
input: unsigned long num_enemies
output: none 
desc: this function initializes the number of enemies specified by num_enemies
*/
void Init_Enemy(unsigned long num_enemies){
	unsigned long i;
	unsigned long right, score;
	const unsigned char * Enemy_Type[2];
	
	E.direction = 1; //go right;
	E.speed = STARTING_SPEED; 
	E.num_enemies = num_enemies;
	E.num_lasers = 0;
	E.enemy_frame = 0;
	E.laser_frame = 0;
	
	
	//randomized the type of enemy
	switch(Generate_Random(0,2)){
			case 0:
				Enemy_Type[0] = SmallEnemy30PointA;
				Enemy_Type[1] = SmallEnemy30PointB;
				score = 30;
				break;
			case 1:
				Enemy_Type[0] = SmallEnemy20PointA;
				Enemy_Type[1] = SmallEnemy20PointB;
				score = 20;
				break;
			case 2:
				Enemy_Type[0] = SmallEnemy10PointA;
				Enemy_Type[1] = SmallEnemy10PointB;
				score = 10;
				break;
		}
	
	
	//initialize 4 enemies per row
	for(i = 0; i<num_enemies; i++){
		
		//init enemy
		E.Enemy[i].id = i;
		E.Enemy[i].x = ENEMY30W *(i % MAX_PER_ROW);
		E.Enemy[i].y = ENEMY30H + ENEMY30H *  floor(i/MAX_PER_ROW);
		E.Enemy[i].w = ENEMY30W;
		E.Enemy[i].h = ENEMY30H;
		E.Enemy[i].can_shoot = 0;
		E.Enemy[i].score = score;
		E.Enemy[i].image[0] = Enemy_Type[0];
		E.Enemy[i].image[1] = Enemy_Type[1];
		E.Enemy[i].image[2] = SmallExplosion0;
		E.Enemy[i].life = 1;
		E.Enemy[i].death = 0;
		
		
		//init laser
		E.Enemy[i].Laser.w = LASERW;
		E.Enemy[i].Laser.h = LASERH;
		E.Enemy[i].Laser.life = 0;
		E.Enemy[i].Laser.direction = 1; //traveling down
		E.Enemy[i].Laser.image[0] = Laser0;
		E.Enemy[i].Laser.image[1] = Laser1;
	}
	
	//initialize enemy linked list
	for(i = 1; i<(num_enemies - 1); i++){
		E.Enemy[i].next = &E.Enemy[i + 1];
		E.Enemy[i].prev = &E.Enemy[i - 1];
	}
	
	E.Enemy[0].next = &E.Enemy[1];
	E.Enemy[0].prev = NULL;
	
	E.Enemy[i].prev = &E.Enemy[i - 1];
	E.Enemy[i].next = NULL;
	
	E.head = &E.Enemy[0];
	E.tail = &E.Enemy[i];
	
	
	//have only the last 4 enemies be able to shoot
	i = 0;
	while(i < MAX_PER_ROW && (num_enemies - 1) >= i){
		E.Enemy[num_enemies - 1 - i].can_shoot = 1;
		i++;
	}

	//find the rightmost and leftmost enemy
	right = (num_enemies > (MAX_PER_ROW-1) ? (MAX_PER_ROW-1) : (num_enemies-1)); 
	E.right = &E.Enemy[right];
	E.left = &E.Enemy[0];
	
	
	//preinit the bonus enemy
	E.BonusEnemy.life = 0;
	
}


/*
input: none
output: none 
desc: this function initializes the stage's number of enemies and bunkers for each level
*/
void Init_Stage(){
	unsigned long i;
	
	Stage.level = 0;
	
	//generate random number of enemies and bunkers
	for(i = 0; i < MAX_STAGES; i++){
			Stage.num_enemies[i] = Generate_Random(2*(i+1), 2*(i+2));
			Stage.num_bunkers[i] = Generate_Random(0,2); 
	}
	//Stage.num_enemies[0] = 8;
	Init_Enemy(Stage.num_enemies[0]); //initialize the enemies
	Init_Bunker(Stage.num_bunkers[0]); //initialize the bunkers
}

/*
input: none
output: none 
desc: this function changes the next level of the stage
*/
void Change_Stage(){

	Init_Enemy(Stage.num_enemies[Stage.level]); //initialize the enemies
	Init_Bunker(Stage.num_bunkers[Stage.level]); //initialize the bunkers
}


/*
input: none
output: none 
desc: this function finds the rightmost and leftmost enemy
*/
void Find_RightLeft(void){
	Enmy* right; 
	Enmy* left;
	unsigned long min = 999999;
	unsigned long max = 0;
	Enmy* enemy = E.head;
	while(enemy != NULL){
		if(enemy->x > max){
			right = enemy;
			max = enemy->x;
		}
		if(enemy->x < min){
			left = enemy;
			min = enemy->x;
		}
		enemy = enemy->next;
	}
	E.left = left;
	E.right = right;
}

/*
input: pointer to an Enmy "enemy"
output: none
desc: this function removes an enemy from the linked lists of enemies
*/
void Remove_Enemy(Enmy* enemy){
	if(enemy == E.head){
		enemy->next->prev = NULL;
		E.head = enemy->next;
	}
	else if(enemy == E.tail){
		enemy->prev->next = NULL;
		E.tail = enemy->prev;
	}
	else{
		enemy->prev->next = enemy->next;
		enemy->next->prev = enemy->prev;
	}
}


/*
input: unsigned long j
output: none
desc: this function removes the jth shooter from the array of enemies who shot
*/
void Remove_Shooter(unsigned long j){
	unsigned long i;
	for(i=j;i<(E.num_lasers-1);i++){
		E.Shot[i] = E.Shot[i+1];
	}
}

/*
input: a pointer to Rect R1 , a pointer to Rect R2 
output: 1 if rectangles overlap, else 0 
desc: this function checks to see whether the two rectangles R1 and R2 overlap
*/
unsigned long Is_Overlapping(Rect* R1, Rect* R2){
	if(R2->L.x < R1->R.x && R1->L.x < R2->R.x && R1->L.y > R2->R.y && R2->L.y > R1->R.y){
		return 1;
	}		
	return 0;
}

/*
input: a pointer to a Wpn called Projectile
output: none 
desc: this function checks whether the weapon pointed by Projectile collides with any other object
*/
void Check_Collision(Wpn* Projectile){
	unsigned long i;
	Enmy* enemy;
	Rect R1 = {{Projectile->x, Projectile->y}, {Projectile->x + Projectile->w - 1, Projectile->y - Projectile->h + 1}};
	Rect R2;
	
	//bunker
	for(i=0; i<B.num_bunkers;i++){
		if(B.Bunker[i].life > 0){
			R2 = (Rect) {{ B.Bunker[i].x, B.Bunker[i].y },{B.Bunker[i].x + B.Bunker[i].w - 1, B.Bunker[i].y - B.Bunker[i].h + 1}};
			if(Is_Overlapping(&R1, &R2) > 0){
				B.Bunker[i].life--;
				Projectile->life = 0;
				return;
			}
		}
	}
	
	//if the projectile came from the player
	if(Projectile == &Player.Missile){
		//enemies
		enemy = E.head;
		while(enemy != NULL){
			R2 = (Rect) {{ enemy->x, enemy->y },{enemy->x + enemy->w - 1, enemy->y - enemy->h + 1}};
			if(Is_Overlapping(&R1, &R2) > 0){
				enemy->life = 0;
				enemy->death = 1; //start the death animation
				
				//remove the enemy from the linked list
				Remove_Enemy(enemy);
				
				
				E.num_enemies--;
				
				//find the next enemy capable of shooting
				if(enemy->id > 4){
					E.Enemy[enemy->id - MAX_PER_ROW].can_shoot = 1; //allow the enemy below the destroyed enemy be able to shoot
				}
				
				//update the rightmost and leftost enemy
				if(E.right == enemy || E.left == enemy){
					Find_RightLeft();
				}
				
				Sound_Killed(); //start the invader death sound
				
				Projectile->life = 0;
				
				Player.Ship.score += enemy->score;
				
				return;
			}
			enemy = enemy->next;
		}
		//bonus enemy
		if(E.BonusEnemy.life > 0){
			R2 = (Rect) {{ E.BonusEnemy.x, E.BonusEnemy.y },{E.BonusEnemy.x + E.BonusEnemy.w - 1, E.BonusEnemy.y - E.BonusEnemy.h + 1}};
			if(Is_Overlapping(&R1, &R2) > 0){
				E.BonusEnemy.life = 0;
				E.BonusEnemy.death = 1; //start the death animation
				
				Sound_Killed(); //start the invader death sound
				
				Projectile->life = 0;
				
				Player.Ship.score += E.BonusEnemy.score; //add score
				
				return;
			}
		}
	}
	//else the projectile came from the enemy
	else{
		R2 = (Rect){{ Player.Ship.x, Player.Ship.y },{Player.Ship.x + Player.Ship.w - 1, Player.Ship.y - Player.Ship.h + 1}};
		//player
		if(Is_Overlapping(&R1, &R2) > 0){
			Player.Ship.life = 0;
			Player.Ship.death = 2; //start the death animation
			
			Sound_Explosion(); //start the explosion sound
			
			Projectile->life = 0;
			return;
		}
		//player missile
		if(Player.Missile.life > 0){
			R2 = (Rect){{ Player.Missile.x, Player.Missile.y },{Player.Missile.x + Player.Missile.w - 1, Player.Missile.y - Player.Missile.h + 1}}; 
			if(Is_Overlapping(&R1, &R2) > 0){
				Player.Missile.life = 0;
				
				Projectile->life = 0;
				return;
			}
		}
	}
	return;
}

/*
input: unsigned long ADCinput
output: none 
desc: this function moves the player based on the value of ADCinput
*/
void Move_Player(unsigned long ADCinput){
	unsigned long player_x = ADCinput / SCALE; // 4095 / 63 = 65

	Player.Ship.x = player_x; //move the player
}


/*
input: none
output: none 
desc: this function moves the Bonus Enemy
*/
void Move_BonusEnemy(void){
	//move the bonus enemy to the right
	if(++E.BonusEnemy.x < (MAX_X - ENEMYBONUSW)){
		Sound_Highpitch(); //start the bonus enemy sound
	}
	//kill the bonus enemy if it has reached the right end of the screen
	else{
		E.BonusEnemy.life = 0;
	}
}

/*
input: a pointer to a Wpn called Projectile
output: none 
desc: this function moves the weapon pointed by Projectile
*/
void Move_Projectile(Wpn* Projectile){
	Projectile->y += Projectile->direction;
	
	//destroy the projectile if the sprite has reached the ends of screen
	if(Projectile->y > MAX_Y || (signed) Projectile->y < 0){
		Projectile->life = 0;
	}
	else{
		Check_Collision(Projectile); //check if any collision has occured after moving the projectile
	}
}

/*
input: signed long x_operand
output: none 
desc: this function moves all living enemies horizontally by x_operand
*/
void Move_X_Enemy(signed long x_operand){
	Enmy* enemy = E.head;
	
	while(enemy != NULL){
		enemy->x += x_operand;
		enemy = enemy->next;
	}
}

/*
input: signd long y_operand
output: none 
desc: this function moves all living enemies vertically by y_operand
*/
void Move_Y_Enemy(signed long y_operand){
	Enmy* enemy = E.head;
	
	
	while(enemy != NULL){
		enemy->y += y_operand;
		enemy = enemy->next;
	}
}

/*
input: none
output: none 
desc: this function updates the enemies locations, spawns in a bonus enemy, and randomly chooses which enemy shoots
*/
void Update_Enemy(void){
	unsigned long i;
	Enmy* enemy;
	
	E.enemy_frame = (E.enemy_frame + 1)&0x01; //update enemy frame
	Sound_Enemy(); //update enemy sound

	//move the enemy down if the enemies has reached the ends of the screen
	if((E.right->x + E.direction) > (MAX_X - ENEMY30W) || (signed)(E.left->x + E.direction) < 0){
		E.direction = -E.direction; //change to opposite direction
		Move_Y_Enemy(2); //move enemies vertically
		if(E.speed < 5){
			E.speed += 1;
			Timer1_Update(BASE_CLOCK>>E.speed); //increase the frequency thus increasing speed of enemy
		}			
	}
	else{
			Move_X_Enemy(E.direction); //move the enemy horizontally
	}
	
	//have one random enemy shoot a laser by random chance
	if(Generate_Random(1,100) > 70 && E.num_lasers < MAX_LASERS){
		i = Generate_Random(0, E.num_enemies - 1); //pick a random element from the linked list
		enemy = E.head;
		
		//traverse through the linked lists until we find the ith enemy
		while(i > 0){
			enemy = enemy->next;
			i--;
		}
		
		//if enemy can shoot and hasn't shot yet, shoot
		if(enemy->can_shoot > 0 && enemy->Laser.life == 0){
			Init_Laser(enemy);
		}
	}
	
	//randomly spawn a bonus enemy if bonus enemy is dead and there is room at the top of the screen
	if((Generate_Random(1,100) > 99) && ((E.head->y - E.head->h) > ENEMY30H) && (E.BonusEnemy.life == 0)){
		Init_BonusEnemy(); //initialize the bonus enemy
	}
}

/*
input: none
output: none 
desc: this function draws the player and missile sprite into Nokia display
*/
void Draw_Player(void){
	
	//draw out the player sprite
	if(Player.Ship.life > 0){
		Nokia5110_PrintBMP(Player.Ship.x, Player.Ship.y, Player.Ship.image[0], 0);
	}
	//play the death animation
	else if(Player.Ship.death > 0){
		Nokia5110_PrintBMP(Player.Ship.x, Player.Ship.y, Player.Ship.image[3 - Player.Ship.death], 0);
		Player.Ship.death--;
	}
	
	//draw out the player missile sprite
	if(Player.Missile.life > 0){
		Nokia5110_PrintBMP(Player.Missile.x, Player.Missile.y, Player.Missile.image[0], 0);
	}
	
}

/*
input: none
output: none 
desc: this function draws the enemies and laser sprite into Nokia display
*/
void Draw_Enemy(void){
	unsigned long i;
	unsigned long num_enemies = Stage.num_enemies[Stage.level];
	
		//draw out the enemy laser sprite
		for(i = 0; i<E.num_lasers; i++){
			Nokia5110_PrintBMP(E.Shot[i]->Laser.x, E.Shot[i]->Laser.y, E.Shot[i]->Laser.image[E.laser_frame], 0);
		}
	
	for(i = 0; i < num_enemies; i++){
		//draw out the enemy sprites
		if(E.Enemy[i].life > 0){
			Nokia5110_PrintBMP(E.Enemy[i].x, E.Enemy[i].y, E.Enemy[i].image[E.enemy_frame], 0);
		}
		//play the death animation
		else if(E.Enemy[i].death > 0){
			Nokia5110_PrintBMP(E.Enemy[i].x, E.Enemy[i].y, E.Enemy[i].image[3 - E.Enemy[i].death], 0);
			E.Enemy[i].death--;
		}
	}
	
	//draw out bonus enemy sprite
	if(E.BonusEnemy.life > 0){
		Nokia5110_PrintBMP(E.BonusEnemy.x, E.BonusEnemy.y, E.BonusEnemy.image[0], 0);
	}
	//play the death animation
	else if(E.BonusEnemy.death > 0){
		Nokia5110_PrintBMP(E.BonusEnemy.x, E.BonusEnemy.y, E.Enemy[i].image[3 - E.BonusEnemy.death], 0);
		E.BonusEnemy.death--;
	}
	
}

/*
input: none
output: none 
desc: this function draws the bunkers sprite into Nokia display
*/
void Draw_Bunker(void){
	unsigned long i;
	for(i=0;i<B.num_bunkers;i++){
		if(B.Bunker[i].life > 0){
			Nokia5110_PrintBMP(B.Bunker[i].x, B.Bunker[i].y, B.Bunker[i].image[3 - B.Bunker[i].life], 0);
		}
	}
}

/*
input: none
output: none 
desc: this function draws all the sprites into Nokia display
*/
void Draw(void){
	
	Nokia5110_ClearBuffer();
	Draw_Player(); //draw out player sprite
	Draw_Enemy(); //draw out all enemy sprites
	Draw_Bunker(); //draw out bunkers
	Nokia5110_DisplayBuffer(); //display the drawings
	
}

/*
input: none
output: none 
desc: this function prints the congrats screen into the Nokia display
*/
void Print_Congrats(void){
	Nokia5110_Clear();
  Nokia5110_SetCursor(1, 1);
  Nokia5110_OutString("YOU ARE A");
  Nokia5110_SetCursor(2, 2);
  Nokia5110_OutString("WINNER!");
  Nokia5110_SetCursor(2, 3);
  Nokia5110_OutString("Score:");
  Nokia5110_SetCursor(2, 4);
  Nokia5110_OutUDec(Player.Ship.score);
	Disable_Update();
}

/*
input: none
output: none 
desc: this function prints the game over screen into the Nokia display
*/
void Print_GameOver(void){
	Nokia5110_Clear();
  Nokia5110_SetCursor(1, 1);
  Nokia5110_OutString("GAME OVER!");
  Nokia5110_SetCursor(2, 3);
  Nokia5110_OutString("Score:");
  Nokia5110_SetCursor(2, 4);
  Nokia5110_OutUDec(Player.Ship.score);
	Disable_Update();
}

/*
input: none
output: none 
desc: this function prints the start screen into the Nokia display
*/
void Print_Start(void){
	Nokia5110_Clear();
	Nokia5110_SetCursor(3, 1);
  Nokia5110_OutString("SPACE");
	Nokia5110_SetCursor(2, 2);
  Nokia5110_OutString("INVADERS");
  Nokia5110_SetCursor(1, 4);
  Nokia5110_OutString("Press Fire");
  Nokia5110_SetCursor(0, 0);
}

/*
input: none
output: none 
desc: this function disables any sprite updates from rendering
*/
void Disable_Update(void){
	TIMER3_CTL_R = 0x00000000; //disable any game updates 
	GPIO_PORTE_IM_R = 0x00000000; //disable player input
}

/*
input: none
output: none 
desc: this function enables any sprite updates to render
*/
void Enable_Update(void){
	TIMER3_CTL_R = 0x00000001; //enable game updates
	GPIO_PORTE_IM_R = 0x00000001; //enable player input
}

/*
input: none
output: none 
desc: this function initializes all timer and edge triggered interrupts
*/
void Init_Interrupts(void){
	unsigned long period;
	
	PortE_EdgeTrigger(); //enable edge trigger interrupt on pe0
	
	Timer1_Init(BASE_CLOCK>>STARTING_SPEED); //timer that updates enemy movement (1Hz)
	
	Timer3_Init(BASE_CLOCK/15); //timer that updates players and projectile movement (15Hz)
	
	period = BASE_CLOCK/11000;
	Timer0_Init(period); //timer that plays sound, non-atomic (11kHz)
	Timer2_Init(period); //timer that plays sound, atomic (11kHz)
	
	
}


/*
input: none
output: none 
desc: this function outputs non-atomic sound to the audio jack for every tick
*/
void Timer0A_Handler(void){
	TIMER0_ICR_R = 0x00000001; //acknowledge interrupt
	SoundA_Play(); //play the non-atomic sound
}

/*
input: none
output: none 
desc: this function outputs atomic sound to the audio jack for every tick
*/
void Timer2A_Handler(void){
	TIMER2_ICR_R = 0x00000001; //acknowledge interrupt
	SoundB_Play(); //play the atomic sound 
}

/*
input: none
output: none 
desc: this function initializes the players missile when PE0 is pressed
*/
void GPIOPortE_Handler(void){
	GPIO_PORTE_ICR_R = 0x01; //acknowledge interrupt
	if(Player.Missile.life == 0){
		LED_Out(0); //turn off the led meaning the missile is in cooldown
		Init_Missile(); //initialize the missile
	}
	/*if((GPIO_PORTE_RIS_R & 0x02) != 0){
		//LED = 0x20;
		GPIO_PORTE_ICR_R = 0x02;
	}*/
}


/*
input: none
output: none 
desc: this function handles moving the laser, missile, bonus enemy, and players sprite for every tick
*/
void Timer3A_Handler(void){
	signed long i;
	TIMER3_ICR_R = 0x00000001; //acknowledge interrupt
	
	ADCdata = ADC_In(); //get potentiometer reading
	
	//update player ship location
	if(ADCdata != prev_ADCdata){
		Move_Player(ADCdata);
		prev_ADCdata = ADCdata;
	}
	
	//update player missile location
	if(Player.Missile.life > 0){
		Move_Projectile(&Player.Missile);
	}
	else{
		LED_Out(0x10); //signify missile is ready
	}
	
	//update enemy laser location
	for(i = (E.num_lasers-1); i>=0; i--){
		Move_Projectile(&(E.Shot[i]->Laser));
		if(E.Shot[i]->Laser.life == 0){
			Remove_Shooter(i);
			E.num_lasers--;
		}
	}
	
	E.laser_frame = (E.laser_frame + 1) & 0x01; //update laser frame
	
	//update bonus enemy location
	if(E.BonusEnemy.life > 0){
		Move_BonusEnemy();
	}
	
	Semaphore = 1; //signify the main thread to draw out new updates
}


/*
input: none
output: none 
desc: this function handles moving the enemy sprites for every tick
*/
void Timer1A_Handler(void){
	TIMER1_ICR_R = 0x00000001; //acknowledge interrupt
	Update_Enemy(); //update enemy location and randomly choose an enemy to shoot
	
}

/*
input: unsigned long period
output: none 
desc: this function updates the timer's countdown time to the value specified by period
*/
void Timer1_Update(unsigned long period){
	TIMER1_CTL_R = 0x00000000; //DISABLE TIMER
	TIMER1_TAILR_R = period - 1; //SET COUNTDOWN VALUE
	TIMER1_CTL_R = 0x00000001; //ENABLE TIMER
}


/*
input: none
output: none 
desc: this function initializes Timer1's configuration and sets the timer's countdown time to the value specified by period
*/
void Timer1_Init(unsigned long period){
	volatile unsigned long delay;
	SYSCTL_RCGCTIMER_R |= 0x02;
	delay = SYSCTL_RCGCTIMER_R;
	
	TIMER1_CTL_R = 0x00000000; //DISABLE TIMER
	TIMER1_CFG_R = 0x00000000; //32-BIT TIMER
	TIMER1_TAMR_R = 0x00000002; //PERIODIC MODE
	TIMER1_TAILR_R = period - 1;
	TIMER1_TAPR_R = 0x00000000; //NO PRE-SCALE
	TIMER1_ICR_R = 0x00000001; //CLEAR INTERRUPT FLAG
	TIMER1_IMR_R = 0x00000001; // ENABLE TIMEOUT INTERRUPT
	NVIC_PRI5_R = (NVIC_PRI5_R & 0xFFFF00FF) | 0x00008000; //IRQ 21
	NVIC_EN0_R |= 1 << 21; //ARM INTERRUPT
	TIMER1_CTL_R = 0x00000001; //ENABLE TIMER
}

/*
input: none
output: none 
desc: this function disables the Systick timer
*/
void Systick_Disable(void){
	NVIC_ST_CTRL_R = 0x00000000;
}

/*
input: none
output: none 
desc: this function initalizes the Systick timer configuration 
*/
void Systick_Init(void){
	//volatile unsigned long delay;
	NVIC_ST_CTRL_R = 0x00000000; //DISABLE SYSTICK
	NVIC_ST_RELOAD_R = 0xFFFFFF; //MAX RELOAD
	NVIC_ST_CURRENT_R = 0; //CLEAR CURRENT
	NVIC_ST_CTRL_R = 0x00000005; //ENABLE CLK, USE SYSTEM CLK
}


int main(void){
	
	TExaS_Init(NoLCD_NoScope); 
	
	
	//initialize hardware
	Nokia5110_Init(); //initialize the nokia display
	Controls_Init(); //initialize switch inputs, leds, and pontentiometer
	Sound_Init(); //initialize DAC to output sound
	Systick_Init(); //initialize Systick timer
	
	Nokia5110_ClearBuffer(); 
	
	Print_Start();
	
	//seed the random number generator
	while((Switch_In() & 0x01) == 0){
		//polling for PE0 to be pressed
	}
	
	Random_Init(NVIC_ST_CURRENT_R); //seed the random number generator using the systick timer value
	Systick_Disable(); //disable the systick timer
	
	Delay100ms(10); //delay for button debouncing
	
	//initialize the game
	Init_Stage(); //initialiaze the stage (enemies and bunkers)
	Init_Player(); //initiliaze he player
	Draw(); //draw out sprites
	
	Init_Interrupts(); //initialize timer and edge triggered interrupts
	EnableInterrupts(); //enable all maskable interrupts
	while(Player.lives > 0){
		Semaphore = 0;
		while(Semaphore == 0){} //wait for new updates to sprites
			
		Draw();
			
		//if there are no more enemies in current stage, change to next level
		if(E.num_enemies == 0){
			Stage.level++;
			if(Stage.level < MAX_STAGES){
				Change_Stage();//change to the next stage level
			}
			else{
				Print_Congrats(); //print the congrats screen for beating all levels
				break;
			}
		}
		//if the death animation is over, restart player life
		if(Player.Ship.death == 0 && Player.Ship.life == 0){
			Disable_Update(); //disable any sprite updates to allow sound to catch up
			while(flag == 0){}; //poll until sound is done
			Delay100ms(20); 
			Enable_Update(); //enable back sprite updates
			Player.Ship.life = 1;
			Player.lives--;
			if(Player.lives == 0){
				Print_GameOver(); //game is over when player run out of lives
				break;
			}
		}
		if(E.tail->y > (MAX_Y - PLAYERH)){
			Print_GameOver(); //game is over when enemy has reached the bottom
			break;
		}
	}
	
	while(1){} 
	
	return 0;
	
}
